-- src/util/pixelfont.lua  Tiny procedural pixel font (3x5 glyphs)
local PixelFont = {}

-- Each glyph is 3 wide x 5 tall, stored as 5 rows of 3-bit patterns
-- Bit order: left=4, middle=2, right=1
local GLYPHS = {}
local function G(char, r1,r2,r3,r4,r5)
    GLYPHS[char] = {r1,r2,r3,r4,r5}
end

-- Letters
G("A", 0x7,0x5,0x7,0x5,0x5)  G("B", 0x6,0x5,0x6,0x5,0x6)
G("C", 0x7,0x4,0x4,0x4,0x7)  G("D", 0x6,0x5,0x5,0x5,0x6)
G("E", 0x7,0x4,0x7,0x4,0x7)  G("F", 0x7,0x4,0x7,0x4,0x4)
G("G", 0x7,0x4,0x5,0x5,0x7)  G("H", 0x5,0x5,0x7,0x5,0x5)
G("I", 0x7,0x2,0x2,0x2,0x7)  G("J", 0x1,0x1,0x1,0x5,0x7)
G("K", 0x5,0x5,0x6,0x5,0x5)  G("L", 0x4,0x4,0x4,0x4,0x7)
G("M", 0x5,0x7,0x7,0x5,0x5)  G("N", 0x5,0x7,0x7,0x7,0x5)
G("O", 0x7,0x5,0x5,0x5,0x7)  G("P", 0x7,0x5,0x7,0x4,0x4)
G("Q", 0x7,0x5,0x5,0x7,0x1)  G("R", 0x7,0x5,0x7,0x6,0x5)
G("S", 0x7,0x4,0x7,0x1,0x7)  G("T", 0x7,0x2,0x2,0x2,0x2)
G("U", 0x5,0x5,0x5,0x5,0x7)  G("V", 0x5,0x5,0x5,0x5,0x2)
G("W", 0x5,0x5,0x7,0x7,0x5)  G("X", 0x5,0x5,0x2,0x5,0x5)
G("Y", 0x5,0x5,0x7,0x2,0x2)  G("Z", 0x7,0x1,0x2,0x4,0x7)
-- Digits
G("0", 0x7,0x5,0x5,0x5,0x7)  G("1", 0x2,0x6,0x2,0x2,0x7)
G("2", 0x7,0x1,0x7,0x4,0x7)  G("3", 0x7,0x1,0x7,0x1,0x7)
G("4", 0x5,0x5,0x7,0x1,0x1)  G("5", 0x7,0x4,0x7,0x1,0x7)
G("6", 0x7,0x4,0x7,0x5,0x7)  G("7", 0x7,0x1,0x1,0x1,0x1)
G("8", 0x7,0x5,0x7,0x5,0x7)  G("9", 0x7,0x5,0x7,0x1,0x7)
-- Punctuation / symbols
G(" ", 0x0,0x0,0x0,0x0,0x0)  G(".", 0x0,0x0,0x0,0x0,0x2)
G(",", 0x0,0x0,0x0,0x2,0x4)  G("!", 0x2,0x2,0x2,0x0,0x2)
G("?", 0x7,0x1,0x3,0x0,0x2)  G(":", 0x0,0x2,0x0,0x2,0x0)
G(";", 0x0,0x2,0x0,0x2,0x4)  G("-", 0x0,0x0,0x7,0x0,0x0)
G("+", 0x0,0x2,0x7,0x2,0x0)  G("=", 0x0,0x7,0x0,0x7,0x0)
G("*", 0x5,0x2,0x5,0x0,0x0)  G("/", 0x1,0x1,0x2,0x4,0x4)
G("(", 0x1,0x2,0x2,0x2,0x1)  G(")", 0x4,0x2,0x2,0x2,0x4)
G("[", 0x3,0x2,0x2,0x2,0x3)  G("]", 0x6,0x2,0x2,0x2,0x6)
G("<", 0x1,0x2,0x4,0x2,0x1)  G(">", 0x4,0x2,0x1,0x2,0x4)
G("#", 0x5,0x7,0x5,0x7,0x5)  G("@", 0x7,0x5,0x7,0x4,0x7)
G("_", 0x0,0x0,0x0,0x0,0x7)  G("'", 0x2,0x2,0x0,0x0,0x0)
G("\"",0x5,0x5,0x0,0x0,0x0)  G("%", 0x5,0x1,0x2,0x4,0x5)
G("^", 0x2,0x5,0x0,0x0,0x0)  G("~", 0x0,0x0,0x5,0x2,0x0)
G("&", 0x6,0x4,0x7,0x5,0x3)  G("|", 0x2,0x2,0x2,0x2,0x2)

local GLYPH_W = 3
local GLYPH_H = 5
local CHAR_GAP = 1  -- 1px between characters
local LINE_GAP = 1  -- 1px between lines

-- Create ImageData for the font atlas (for fast drawing)
local atlas = nil
local quads = {}
local atlasImage = nil

local function buildAtlas()
    -- lay out all printable ASCII 32..126 in a row
    local count = 95  -- chars 32..126
    local aw = count * (GLYPH_W + 1)
    local ah = GLYPH_H
    atlas = love.image.newImageData(aw, ah)
    -- fill transparent
    atlas:mapPixel(function() return 0,0,0,0 end)

    for ci = 32, 126 do
        local ch = string.char(ci)
        local g = GLYPHS[ch] or GLYPHS[" "]
        local ox = (ci - 32) * (GLYPH_W + 1)
        for row = 0, GLYPH_H - 1 do
            local bits = g[row+1]
            for col = 0, GLYPH_W - 1 do
                local bit = GLYPH_W - 1 - col
                if bits and math.floor(bits / (2^bit)) % 2 == 1 then
                    atlas:setPixel(ox + col, row, 1, 1, 1, 1)
                end
            end
        end
        quads[ci] = love.graphics.newQuad(ox, 0, GLYPH_W, GLYPH_H, aw, ah)
    end

    atlasImage = love.graphics.newImage(atlas)
    atlasImage:setFilter("nearest", "nearest")
end

function PixelFont.init()
    buildAtlas()
end

-- Draw text at (x,y) with optional scale
function PixelFont.print(text, x, y, scale, r, g, b, a)
    if not atlasImage then buildAtlas() end
    scale = scale or 1
    r = r or 1; g = g or 1; b = b or 1; a = a or 1
    love.graphics.setColor(r, g, b, a)
    local cx, cy = x, y
    local str = string.upper(tostring(text))
    for i = 1, #str do
        local ch = str:sub(i, i)
        local code = string.byte(ch)
        if ch == "\n" then
            cx = x
            cy = cy + (GLYPH_H + LINE_GAP) * scale
        elseif code >= 32 and code <= 126 and quads[code] then
            love.graphics.draw(atlasImage, quads[code], cx, cy, 0, scale, scale)
            cx = cx + (GLYPH_W + CHAR_GAP) * scale
        else
            cx = cx + (GLYPH_W + CHAR_GAP) * scale
        end
    end
end

-- Measure text dimensions
function PixelFont.measure(text, scale)
    scale = scale or 1
    local str = string.upper(tostring(text))
    local maxw, lines = 0, 1
    local cw = 0
    for i = 1, #str do
        local ch = str:sub(i, i)
        if ch == "\n" then
            if cw > maxw then maxw = cw end
            cw = 0
            lines = lines + 1
        else
            cw = cw + (GLYPH_W + CHAR_GAP) * scale
        end
    end
    if cw > maxw then maxw = cw end
    maxw = maxw - CHAR_GAP * scale  -- remove trailing gap
    if maxw < 0 then maxw = 0 end
    local h = (GLYPH_H * lines + LINE_GAP * (lines - 1)) * scale
    return maxw, h
end

PixelFont.GLYPH_W = GLYPH_W
PixelFont.GLYPH_H = GLYPH_H
PixelFont.CHAR_GAP = CHAR_GAP
PixelFont.LINE_GAP = LINE_GAP
PixelFont.charWidth  = function(s) return (GLYPH_W + CHAR_GAP) * (s or 1) end
PixelFont.lineHeight = function(s) return (GLYPH_H + LINE_GAP) * (s or 1) end

return PixelFont
